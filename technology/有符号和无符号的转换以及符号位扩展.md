### 1.转换陷阱
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int test(char *s, char *t)
{
    size_t tmp1 =  strlen(s);
    size_t tmp2 =  strlen(t);
    size_t diff = tmp1 - tmp2;
    printf("diff:%lu\n",diff); //18446744073709551615
    printf("diff:%ld\n",(long)diff); //-1
    printf("diff:%x\n",diff); //ffffffff
    if(diff > 0) return 1;  
    else return 0;
}

int main()
{
    char *s1 = "123";
    char *s2 = "1245";
    int res = test(s1, s2);
    printf("%d\n", res);  // 竟然返回1
}
```
为什么上面的s1的长度小于s2的长度，但是上面的diff是返回1，理论上应该是小于0的。

**原因：**
C语言中将size_t定义为unsigned int，当s比t短时,strlen(s) - strlen(t)为负数，但**无符号数的运算结果隐式转换为无符号数就变成了很大的无符号数**.
由上面的打印可知，打印%ld的时候是-1，这个是容易造成误区的地方。明明是-1，我什么判断还是大于0呢。
相关知识点：
1. 当你使用printf %ld的时候，已经默认的进行了一次转化。因为diff原本是unsign long类型的（64位系统）。相当于是把无符号数转换成有符号数，参考第二条得知。目前内存是ffffffff(由打印的16进制得到的。)，最高位为1，求补码，最终得到-1.
2. 转换规则是什么:**牵扯到无符号数和有符号数之间的转换。** 

    一句话：**有符号数与无符号数之间的转换，都要看要转换的数的最高位是否为1，如果不为1，则转换结果就是要转换的数的本身；如果为1，则转换结果就是转换的数（看作是负数）的补码。**

3. 所以一般是看打印的16进制是什么？ 因为打印出来的16进制就表示内存目前的实际值是什么。至于%d, %u等，其实都是转换过的，也就是同样的内存，不同的解析方式得到的值是不一样的。得到16进制后，再看目前的类型是什么（有符号还是无符号的）。

**正确的：**

```
int test2(char *s, char *t)
{
     return strlen(s) > strlen(t);
}
```

### 2.有、无符号数之间的运算
```
#include <stdio.h>
int main(void)
{
    unsigned int a = 6;
    int b = -20;

    if ( a+b > 6 )
        printf("a+b大于6\n");  //输出这个
    else
        printf("a+b小于6\n");

    return 0;
}
```

原因是因为编译器会将有符号数b转换成为一个无符号数，即此处a+b等价于a+(unsigned int)b.  参考第一条，-20按照转换规则，转换成一个很大的数字了。

C 语言按照一定的规则来进行此类运算的转换，这种规则称为正常算术转换，转换的顺序为：
```
double>float>unsigned long>long>unsigned int>int
```
